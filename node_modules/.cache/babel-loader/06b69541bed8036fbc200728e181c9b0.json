{"ast":null,"code":"import * as React from 'react';\nimport useLatest from '@react-hook/latest';\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\n\nexport function useInfiniteLoader(loadMoreItems, options = emptyObj) {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9\n  } = options;\n  const storedLoadMoreItems = useLatest(loadMoreItems);\n  const storedIsItemLoaded = useLatest(isItemLoaded);\n  return React.useCallback((startIndex, stopIndex, items) => {\n    const unloadedRanges = scanForUnloadedRanges(storedIsItemLoaded.current, minimumBatchSize, items, totalItems, Math.max(0, startIndex - threshold), Math.min(totalItems - 1, (stopIndex || 0) + threshold)); // The user is responsible for memoizing their loadMoreItems() function\n    // because we don't want to make assumptions about how they want to deal\n    // with `items`\n\n    for (let i = 0; i < unloadedRanges.length - 1; ++i) storedLoadMoreItems.current(unloadedRanges[i], unloadedRanges[++i], items);\n  }, [totalItems, minimumBatchSize, threshold, storedLoadMoreItems, storedIsItemLoaded]);\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nfunction scanForUnloadedRanges(isItemLoaded = defaultIsItemLoaded, minimumBatchSize = 16, items, totalItems = 9e9, startIndex, stopIndex) {\n  const unloadedRanges = [];\n  let rangeStartIndex,\n      rangeStopIndex,\n      index = startIndex;\n  /* istanbul ignore next */\n\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === void 0) rangeStartIndex = index;\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = void 0;\n    }\n  } // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), totalItems - 1);\n    /* istanbul ignore next */\n\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n  /* istanbul ignore next */\n\n\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0];\n    const firstUnloadedStop = unloadedRanges[1];\n\n    while (firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize && firstUnloadedStart > 0) {\n      const index = firstUnloadedStart - 1;\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nconst defaultIsItemLoaded = (index, items) => items[index] !== void 0;\n\nconst emptyObj = {};","map":{"version":3,"sources":["D:/Users/abdel/Documents/Safe/Code/Bootcamp/frontest/node_modules/masonic/dist/module/use-infinite-loader.js"],"names":["React","useLatest","useInfiniteLoader","loadMoreItems","options","emptyObj","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","useCallback","startIndex","stopIndex","items","unloadedRanges","scanForUnloadedRanges","current","Math","max","min","i","length","defaultIsItemLoaded","rangeStartIndex","rangeStopIndex","index","push","potentialStopIndex","firstUnloadedStart","firstUnloadedStop"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport useLatest from '@react-hook/latest';\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\n\nexport function useInfiniteLoader(loadMoreItems, options = emptyObj) {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9\n  } = options;\n  const storedLoadMoreItems = useLatest(loadMoreItems);\n  const storedIsItemLoaded = useLatest(isItemLoaded);\n  return React.useCallback((startIndex, stopIndex, items) => {\n    const unloadedRanges = scanForUnloadedRanges(storedIsItemLoaded.current, minimumBatchSize, items, totalItems, Math.max(0, startIndex - threshold), Math.min(totalItems - 1, (stopIndex || 0) + threshold)); // The user is responsible for memoizing their loadMoreItems() function\n    // because we don't want to make assumptions about how they want to deal\n    // with `items`\n\n    for (let i = 0; i < unloadedRanges.length - 1; ++i) storedLoadMoreItems.current(unloadedRanges[i], unloadedRanges[++i], items);\n  }, [totalItems, minimumBatchSize, threshold, storedLoadMoreItems, storedIsItemLoaded]);\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nfunction scanForUnloadedRanges(isItemLoaded = defaultIsItemLoaded, minimumBatchSize = 16, items, totalItems = 9e9, startIndex, stopIndex) {\n  const unloadedRanges = [];\n  let rangeStartIndex,\n      rangeStopIndex,\n      index = startIndex;\n  /* istanbul ignore next */\n\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === void 0) rangeStartIndex = index;\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = void 0;\n    }\n  } // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), totalItems - 1);\n    /* istanbul ignore next */\n\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n  /* istanbul ignore next */\n\n\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0];\n    const firstUnloadedStop = unloadedRanges[1];\n\n    while (firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize && firstUnloadedStart > 0) {\n      const index = firstUnloadedStart - 1;\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nconst defaultIsItemLoaded = (index, items) => items[index] !== void 0;\n\nconst emptyObj = {};"]},"metadata":{},"sourceType":"module"}