{"ast":null,"code":"const createCache = obj => {\n  try {\n    // @ts-ignore\n    return new obj();\n  } catch (e) {\n    const cache = {};\n    return {\n      set(k, v) {\n        cache[k] = v;\n      },\n\n      get(k) {\n        return cache[k];\n      }\n\n    };\n  }\n};\n\nconst memo = constructors => {\n  const depth = constructors.length,\n        baseCache = createCache(constructors[0]);\n  let base;\n  let map;\n  let i;\n  let node;\n  const one = depth === 1; // quicker access for one and two-argument functions\n\n  const g1 = args => (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1]);\n\n  const s1 = (args, value) => {\n    if (one) baseCache.set(args[0], value);else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1]);\n        map.set(args[1], value);\n        baseCache.set(args[0], map);\n      } else {\n        base.set(args[1], value);\n      }\n    }\n    return value;\n  };\n\n  const g2 = args => {\n    node = baseCache;\n\n    for (i = 0; i < depth; i++) if ((node = node.get(args[i])) === void 0) return;\n\n    return node;\n  };\n\n  const s2 = (args, value) => {\n    node = baseCache;\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1]);\n        node.set(args[i], map);\n        node = map;\n      } else {\n        node = map;\n      }\n    }\n\n    node.set(args[depth - 1], value);\n    return value;\n  };\n\n  return depth < 3 ? {\n    g: g1,\n    s: s1\n  } : {\n    g: g2,\n    s: s2\n  };\n};\n\nconst memoize = (mapConstructors, fn) => {\n  let item;\n  const {\n    g,\n    s\n  } = memo(mapConstructors);\n  return function () {\n    return (item = g(arguments)) === void 0 ? s(arguments, fn.apply(null, arguments)) : item;\n  };\n};\n\nexport default memoize;","map":{"version":3,"sources":["D:/Users/abdel/Documents/Safe/Code/Bootcamp/frontest/node_modules/trie-memoize/dist/module/index.js"],"names":["createCache","obj","e","cache","set","k","v","get","memo","constructors","depth","length","baseCache","base","map","i","node","one","g1","args","s1","value","g2","s2","g","s","memoize","mapConstructors","fn","item","arguments","apply"],"mappings":"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","sourcesContent":["const createCache = obj => {\n  try {\n    // @ts-ignore\n    return new obj();\n  } catch (e) {\n    const cache = {};\n    return {\n      set(k, v) {\n        cache[k] = v;\n      },\n\n      get(k) {\n        return cache[k];\n      }\n\n    };\n  }\n};\n\nconst memo = constructors => {\n  const depth = constructors.length,\n        baseCache = createCache(constructors[0]);\n  let base;\n  let map;\n  let i;\n  let node;\n  const one = depth === 1; // quicker access for one and two-argument functions\n\n  const g1 = args => (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1]);\n\n  const s1 = (args, value) => {\n    if (one) baseCache.set(args[0], value);else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1]);\n        map.set(args[1], value);\n        baseCache.set(args[0], map);\n      } else {\n        base.set(args[1], value);\n      }\n    }\n    return value;\n  };\n\n  const g2 = args => {\n    node = baseCache;\n\n    for (i = 0; i < depth; i++) if ((node = node.get(args[i])) === void 0) return;\n\n    return node;\n  };\n\n  const s2 = (args, value) => {\n    node = baseCache;\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1]);\n        node.set(args[i], map);\n        node = map;\n      } else {\n        node = map;\n      }\n    }\n\n    node.set(args[depth - 1], value);\n    return value;\n  };\n\n  return depth < 3 ? {\n    g: g1,\n    s: s1\n  } : {\n    g: g2,\n    s: s2\n  };\n};\n\nconst memoize = (mapConstructors, fn) => {\n  let item;\n  const {\n    g,\n    s\n  } = memo(mapConstructors);\n  return function () {\n    return (item = g(arguments)) === void 0 ? s(arguments, fn.apply(null, arguments)) : item;\n  };\n};\n\nexport default memoize;"]},"metadata":{},"sourceType":"module"}