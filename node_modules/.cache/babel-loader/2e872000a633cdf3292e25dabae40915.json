{"ast":null,"code":"import * as React from 'react';\nimport trieMemoize from 'trie-memoize';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport rafSchd from 'raf-schd';\nimport { elementsCache } from './elements-cache';\nimport { useForceUpdate } from './use-force-update';\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\n\nexport function useResizeObserver(positioner) {\n  const forceUpdate = useForceUpdate();\n  const resizeObserver = createResizeObserver(positioner, forceUpdate); // Cleans up the resize observers when they change or the\n  // component unmounts\n\n  function _ref() {\n    return resizeObserver.disconnect();\n  }\n\n  React.useEffect(() => _ref, [resizeObserver]);\n  return resizeObserver;\n}\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\n\nexport const createResizeObserver = /*#__PURE__*/trieMemoize([WeakMap], // TODO: figure out a way to test this\n\n/* istanbul ignore next */\n(positioner, updater) => {\n  const handleEntries = rafSchd(entries => {\n    const updates = [];\n    let i = 0;\n\n    for (; i < entries.length; i++) {\n      const entry = entries[i];\n      const height = entry.target.offsetHeight;\n\n      if (height > 0) {\n        const index = elementsCache.get(entry.target);\n\n        if (index !== void 0) {\n          const position = positioner.get(index);\n          if (position !== void 0 && height !== position.height) updates.push(index, height);\n        }\n      }\n    }\n\n    if (updates.length > 0) {\n      // Updates the size/positions of the cell with the resize\n      // observer updates\n      positioner.update(updates);\n      updater(updates);\n    }\n  });\n  const ro = new ResizeObserver(handleEntries); // Overrides the original disconnect to include cancelling handling the entries.\n  // Ideally this would be its own method but that would result in a breaking\n  // change.\n\n  const disconnect = ro.disconnect.bind(ro);\n\n  ro.disconnect = () => {\n    disconnect();\n    handleEntries.cancel();\n  };\n\n  return ro;\n});","map":{"version":3,"sources":["D:/Users/abdel/Documents/Safe/Code/Bootcamp/frontest/node_modules/masonic/dist/module/use-resize-observer.js"],"names":["React","trieMemoize","ResizeObserver","rafSchd","elementsCache","useForceUpdate","useResizeObserver","positioner","forceUpdate","resizeObserver","createResizeObserver","_ref","disconnect","useEffect","WeakMap","updater","handleEntries","entries","updates","i","length","entry","height","target","offsetHeight","index","get","position","push","update","ro","bind","cancel"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,WAAP,MAAwB,cAAxB;AACA,OAAOC,cAAP,MAA2B,0BAA3B;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,SAASC,aAAT,QAA8B,kBAA9B;AACA,SAASC,cAAT,QAA+B,oBAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,UAA3B,EAAuC;AAC5C,QAAMC,WAAW,GAAGH,cAAc,EAAlC;AACA,QAAMI,cAAc,GAAGC,oBAAoB,CAACH,UAAD,EAAaC,WAAb,CAA3C,CAF4C,CAE0B;AACtE;;AAEA,WAASG,IAAT,GAAgB;AACd,WAAOF,cAAc,CAACG,UAAf,EAAP;AACD;;AAEDZ,EAAAA,KAAK,CAACa,SAAN,CAAgB,MAAMF,IAAtB,EAA4B,CAACF,cAAD,CAA5B;AACA,SAAOA,cAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,oBAAoB,GAAG,aAAaT,WAAW,CAAC,CAACa,OAAD,CAAD,EAAY;;AAExE;AACA,CAACP,UAAD,EAAaQ,OAAb,KAAyB;AACvB,QAAMC,aAAa,GAAGb,OAAO,CAACc,OAAO,IAAI;AACvC,UAAMC,OAAO,GAAG,EAAhB;AACA,QAAIC,CAAC,GAAG,CAAR;;AAEA,WAAOA,CAAC,GAAGF,OAAO,CAACG,MAAnB,EAA2BD,CAAC,EAA5B,EAAgC;AAC9B,YAAME,KAAK,GAAGJ,OAAO,CAACE,CAAD,CAArB;AACA,YAAMG,MAAM,GAAGD,KAAK,CAACE,MAAN,CAAaC,YAA5B;;AAEA,UAAIF,MAAM,GAAG,CAAb,EAAgB;AACd,cAAMG,KAAK,GAAGrB,aAAa,CAACsB,GAAd,CAAkBL,KAAK,CAACE,MAAxB,CAAd;;AAEA,YAAIE,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpB,gBAAME,QAAQ,GAAGpB,UAAU,CAACmB,GAAX,CAAeD,KAAf,CAAjB;AACA,cAAIE,QAAQ,KAAK,KAAK,CAAlB,IAAuBL,MAAM,KAAKK,QAAQ,CAACL,MAA/C,EAAuDJ,OAAO,CAACU,IAAR,CAAaH,KAAb,EAAoBH,MAApB;AACxD;AACF;AACF;;AAED,QAAIJ,OAAO,CAACE,MAAR,GAAiB,CAArB,EAAwB;AACtB;AACA;AACAb,MAAAA,UAAU,CAACsB,MAAX,CAAkBX,OAAlB;AACAH,MAAAA,OAAO,CAACG,OAAD,CAAP;AACD;AACF,GAxB4B,CAA7B;AAyBA,QAAMY,EAAE,GAAG,IAAI5B,cAAJ,CAAmBc,aAAnB,CAAX,CA1BuB,CA0BuB;AAC9C;AACA;;AAEA,QAAMJ,UAAU,GAAGkB,EAAE,CAAClB,UAAH,CAAcmB,IAAd,CAAmBD,EAAnB,CAAnB;;AAEAA,EAAAA,EAAE,CAAClB,UAAH,GAAgB,MAAM;AACpBA,IAAAA,UAAU;AACVI,IAAAA,aAAa,CAACgB,MAAd;AACD,GAHD;;AAKA,SAAOF,EAAP;AACD,CAzC2D,CAArD","sourcesContent":["import * as React from 'react';\nimport trieMemoize from 'trie-memoize';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport rafSchd from 'raf-schd';\nimport { elementsCache } from './elements-cache';\nimport { useForceUpdate } from './use-force-update';\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport function useResizeObserver(positioner) {\n  const forceUpdate = useForceUpdate();\n  const resizeObserver = createResizeObserver(positioner, forceUpdate); // Cleans up the resize observers when they change or the\n  // component unmounts\n\n  function _ref() {\n    return resizeObserver.disconnect();\n  }\n\n  React.useEffect(() => _ref, [resizeObserver]);\n  return resizeObserver;\n}\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\n\nexport const createResizeObserver = /*#__PURE__*/trieMemoize([WeakMap], // TODO: figure out a way to test this\n\n/* istanbul ignore next */\n(positioner, updater) => {\n  const handleEntries = rafSchd(entries => {\n    const updates = [];\n    let i = 0;\n\n    for (; i < entries.length; i++) {\n      const entry = entries[i];\n      const height = entry.target.offsetHeight;\n\n      if (height > 0) {\n        const index = elementsCache.get(entry.target);\n\n        if (index !== void 0) {\n          const position = positioner.get(index);\n          if (position !== void 0 && height !== position.height) updates.push(index, height);\n        }\n      }\n    }\n\n    if (updates.length > 0) {\n      // Updates the size/positions of the cell with the resize\n      // observer updates\n      positioner.update(updates);\n      updater(updates);\n    }\n  });\n  const ro = new ResizeObserver(handleEntries); // Overrides the original disconnect to include cancelling handling the entries.\n  // Ideally this would be its own method but that would result in a breaking\n  // change.\n\n  const disconnect = ro.disconnect.bind(ro);\n\n  ro.disconnect = () => {\n    disconnect();\n    handleEntries.cancel();\n  };\n\n  return ro;\n});"]},"metadata":{},"sourceType":"module"}